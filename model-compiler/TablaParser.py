# Generated from Tabla.g by ANTLR 4.5.1
# encoding: utf-8
from antlr4 import *
from io import StringIO

def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u0430\ud6d1\u8206\uad2d\u4417\uaef1\u8d80\uaadd\3 ")
        buf.write("\u00cc\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\3\2\3\2")
        buf.write("\3\2\3\2\3\3\7\3@\n\3\f\3\16\3C\13\3\3\4\3\4\3\4\3\5\3")
        buf.write("\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\5\5S\n\5\3\6\3")
        buf.write("\6\3\7\3\7\3\b\3\b\3\b\3\b\3\b\3\t\3\t\3\t\3\t\3\t\5\t")
        buf.write("c\n\t\3\n\3\n\3\n\3\13\3\13\3\f\3\f\3\f\3\r\3\r\3\r\3")
        buf.write("\r\3\r\5\rr\n\r\3\16\3\16\3\16\5\16w\n\16\3\17\3\17\3")
        buf.write("\17\3\17\3\17\3\17\3\17\3\20\7\20\u0081\n\20\f\20\16\20")
        buf.write("\u0084\13\20\3\20\5\20\u0087\n\20\3\21\3\21\3\21\3\21")
        buf.write("\3\21\3\22\3\22\3\22\3\23\3\23\3\24\3\24\3\24\3\24\3\24")
        buf.write("\3\24\3\24\3\24\3\24\3\24\3\24\5\24\u009e\n\24\3\25\3")
        buf.write("\25\3\25\3\25\3\25\5\25\u00a5\n\25\3\26\3\26\3\26\3\27")
        buf.write("\3\27\3\27\3\27\3\27\5\27\u00af\n\27\3\30\3\30\3\30\3")
        buf.write("\31\3\31\3\31\3\31\3\31\5\31\u00b9\n\31\3\32\3\32\3\32")
        buf.write("\3\32\3\32\3\32\3\32\3\32\3\32\5\32\u00c4\n\32\3\33\3")
        buf.write("\33\3\34\3\34\3\35\3\35\3\35\2\2\36\2\4\6\b\n\f\16\20")
        buf.write("\22\24\26\30\32\34\36 \"$&(*,.\60\62\64\668\2\7\3\2\4")
        buf.write("\6\4\2\35\35  \3\2\16\24\3\2\t\n\3\2\13\f\u00bf\2:\3\2")
        buf.write("\2\2\4A\3\2\2\2\6D\3\2\2\2\bR\3\2\2\2\nT\3\2\2\2\fV\3")
        buf.write("\2\2\2\16X\3\2\2\2\20b\3\2\2\2\22d\3\2\2\2\24g\3\2\2\2")
        buf.write("\26i\3\2\2\2\30q\3\2\2\2\32v\3\2\2\2\34x\3\2\2\2\36\u0086")
        buf.write("\3\2\2\2 \u0088\3\2\2\2\"\u008d\3\2\2\2$\u0090\3\2\2\2")
        buf.write("&\u009d\3\2\2\2(\u00a4\3\2\2\2*\u00a6\3\2\2\2,\u00ae\3")
        buf.write("\2\2\2.\u00b0\3\2\2\2\60\u00b8\3\2\2\2\62\u00c3\3\2\2")
        buf.write("\2\64\u00c5\3\2\2\2\66\u00c7\3\2\2\28\u00c9\3\2\2\2:;")
        buf.write("\5\4\3\2;<\5\36\20\2<=\7\2\2\3=\3\3\2\2\2>@\5\6\4\2?>")
        buf.write("\3\2\2\2@C\3\2\2\2A?\3\2\2\2AB\3\2\2\2B\5\3\2\2\2CA\3")
        buf.write("\2\2\2DE\5\b\5\2EF\7\25\2\2F\7\3\2\2\2GH\5\n\6\2HI\5\22")
        buf.write("\n\2IS\3\2\2\2JK\7\7\2\2KS\5\16\b\2LM\5\f\7\2MN\5\34\17")
        buf.write("\2NS\3\2\2\2OP\7\35\2\2PQ\7\34\2\2QS\7 \2\2RG\3\2\2\2")
        buf.write("RJ\3\2\2\2RL\3\2\2\2RO\3\2\2\2S\t\3\2\2\2TU\t\2\2\2U\13")
        buf.write("\3\2\2\2VW\7\b\2\2W\r\3\2\2\2XY\5\24\13\2YZ\7\3\2\2Z[")
        buf.write("\5\24\13\2[\\\5\20\t\2\\\17\3\2\2\2]^\7\33\2\2^_\5\16")
        buf.write("\b\2_`\5\20\t\2`c\3\2\2\2ac\3\2\2\2b]\3\2\2\2ba\3\2\2")
        buf.write("\2c\21\3\2\2\2de\5\24\13\2ef\5\32\16\2f\23\3\2\2\2gh\5")
        buf.write("\26\f\2h\25\3\2\2\2ij\7\35\2\2jk\5\30\r\2k\27\3\2\2\2")
        buf.write("lm\7\27\2\2mn\t\3\2\2no\7\30\2\2or\5\30\r\2pr\3\2\2\2")
        buf.write("ql\3\2\2\2qp\3\2\2\2r\31\3\2\2\2st\7\33\2\2tw\5\22\n\2")
        buf.write("uw\3\2\2\2vs\3\2\2\2vu\3\2\2\2w\33\3\2\2\2xy\7\35\2\2")
        buf.write("yz\7\27\2\2z{\t\3\2\2{|\7\26\2\2|}\t\3\2\2}~\7\30\2\2")
        buf.write("~\35\3\2\2\2\177\u0081\5 \21\2\u0080\177\3\2\2\2\u0081")
        buf.write("\u0084\3\2\2\2\u0082\u0080\3\2\2\2\u0082\u0083\3\2\2\2")
        buf.write("\u0083\u0087\3\2\2\2\u0084\u0082\3\2\2\2\u0085\u0087\3")
        buf.write("\2\2\2\u0086\u0082\3\2\2\2\u0086\u0085\3\2\2\2\u0087\37")
        buf.write("\3\2\2\2\u0088\u0089\5\24\13\2\u0089\u008a\7\34\2\2\u008a")
        buf.write("\u008b\5\"\22\2\u008b\u008c\7\25\2\2\u008c!\3\2\2\2\u008d")
        buf.write("\u008e\5*\26\2\u008e\u008f\5(\25\2\u008f#\3\2\2\2\u0090")
        buf.write("\u0091\t\4\2\2\u0091%\3\2\2\2\u0092\u0093\7\27\2\2\u0093")
        buf.write("\u0094\7\35\2\2\u0094\u0095\7\30\2\2\u0095\u0096\7\31")
        buf.write("\2\2\u0096\u0097\5\"\22\2\u0097\u0098\7\32\2\2\u0098\u009e")
        buf.write("\3\2\2\2\u0099\u009a\7\31\2\2\u009a\u009b\5\"\22\2\u009b")
        buf.write("\u009c\7\32\2\2\u009c\u009e\3\2\2\2\u009d\u0092\3\2\2")
        buf.write("\2\u009d\u0099\3\2\2\2\u009e\'\3\2\2\2\u009f\u00a0\58")
        buf.write("\35\2\u00a0\u00a1\5*\26\2\u00a1\u00a2\5(\25\2\u00a2\u00a5")
        buf.write("\3\2\2\2\u00a3\u00a5\3\2\2\2\u00a4\u009f\3\2\2\2\u00a4")
        buf.write("\u00a3\3\2\2\2\u00a5)\3\2\2\2\u00a6\u00a7\5.\30\2\u00a7")
        buf.write("\u00a8\5,\27\2\u00a8+\3\2\2\2\u00a9\u00aa\5\66\34\2\u00aa")
        buf.write("\u00ab\5.\30\2\u00ab\u00ac\5,\27\2\u00ac\u00af\3\2\2\2")
        buf.write("\u00ad\u00af\3\2\2\2\u00ae\u00a9\3\2\2\2\u00ae\u00ad\3")
        buf.write("\2\2\2\u00af-\3\2\2\2\u00b0\u00b1\5\62\32\2\u00b1\u00b2")
        buf.write("\5\60\31\2\u00b2/\3\2\2\2\u00b3\u00b4\5\64\33\2\u00b4")
        buf.write("\u00b5\5\62\32\2\u00b5\u00b6\5\60\31\2\u00b6\u00b9\3\2")
        buf.write("\2\2\u00b7\u00b9\3\2\2\2\u00b8\u00b3\3\2\2\2\u00b8\u00b7")
        buf.write("\3\2\2\2\u00b9\61\3\2\2\2\u00ba\u00c4\5\24\13\2\u00bb")
        buf.write("\u00bc\7\31\2\2\u00bc\u00bd\5\"\22\2\u00bd\u00be\7\32")
        buf.write("\2\2\u00be\u00c4\3\2\2\2\u00bf\u00c4\7 \2\2\u00c0\u00c1")
        buf.write("\5$\23\2\u00c1\u00c2\5&\24\2\u00c2\u00c4\3\2\2\2\u00c3")
        buf.write("\u00ba\3\2\2\2\u00c3\u00bb\3\2\2\2\u00c3\u00bf\3\2\2\2")
        buf.write("\u00c3\u00c0\3\2\2\2\u00c4\63\3\2\2\2\u00c5\u00c6\7\r")
        buf.write("\2\2\u00c6\65\3\2\2\2\u00c7\u00c8\t\5\2\2\u00c8\67\3\2")
        buf.write("\2\2\u00c9\u00ca\t\6\2\2\u00ca9\3\2\2\2\16ARbqv\u0082")
        buf.write("\u0086\u009d\u00a4\u00ae\u00b8\u00c3")
        return buf.getvalue()


class TablaParser ( Parser ):

    grammarFileName = "Tabla.g"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'->'", "'model_input'", "'model_output'", 
                     "'model'", "'gradient'", "'iterator'", "'+'", "'-'", 
                     "'<'", "'>'", "'*'", "'pi'", "'sum'", "'norm'", "'gaussian'", 
                     "'sigmoid'", "'sigmoid_symmetric'", "'log'", "';'", 
                     "':'", "'['", "']'", "'('", "')'", "','", "'='" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "MODEL_INPUT", "MODEL_OUTPUT", 
                      "MODEL", "GRADIENT", "ITERATOR", "ADD", "SUB", "LT", 
                      "GT", "MUL", "PI", "SUM", "NORM", "GAUSSIAN", "SIGMOID", 
                      "SIG_SYM", "LOG", "SEMI", "COLON", "LEFT_BRACK", "RIGHT_BRACK", 
                      "LEFT_PAREN", "RIGHT_PAREN", "COMMA", "ASSIGN", "ID", 
                      "WHITESPACE", "COMMENT", "INTLIT" ]

    RULE_program = 0
    RULE_data_decl_list = 1
    RULE_data_decl = 2
    RULE_data_type = 3
    RULE_non_iterator = 4
    RULE_iterator = 5
    RULE_var_with_link_list = 6
    RULE_var_with_link_list_tail = 7
    RULE_var_list = 8
    RULE_var = 9
    RULE_var_id = 10
    RULE_id_tail = 11
    RULE_var_list_tail = 12
    RULE_var_list_iterator = 13
    RULE_stat_list = 14
    RULE_stat = 15
    RULE_expr = 16
    RULE_function = 17
    RULE_function_args = 18
    RULE_term2_tail = 19
    RULE_term2 = 20
    RULE_term1_tail = 21
    RULE_term1 = 22
    RULE_term0_tail = 23
    RULE_term0 = 24
    RULE_mul_op = 25
    RULE_add_op = 26
    RULE_compare_op = 27

    ruleNames =  [ "program", "data_decl_list", "data_decl", "data_type", 
                   "non_iterator", "iterator", "var_with_link_list", "var_with_link_list_tail", 
                   "var_list", "var", "var_id", "id_tail", "var_list_tail", 
                   "var_list_iterator", "stat_list", "stat", "expr", "function", 
                   "function_args", "term2_tail", "term2", "term1_tail", 
                   "term1", "term0_tail", "term0", "mul_op", "add_op", "compare_op" ]

    EOF = Token.EOF
    T__0=1
    MODEL_INPUT=2
    MODEL_OUTPUT=3
    MODEL=4
    GRADIENT=5
    ITERATOR=6
    ADD=7
    SUB=8
    LT=9
    GT=10
    MUL=11
    PI=12
    SUM=13
    NORM=14
    GAUSSIAN=15
    SIGMOID=16
    SIG_SYM=17
    LOG=18
    SEMI=19
    COLON=20
    LEFT_BRACK=21
    RIGHT_BRACK=22
    LEFT_PAREN=23
    RIGHT_PAREN=24
    COMMA=25
    ASSIGN=26
    ID=27
    WHITESPACE=28
    COMMENT=29
    INTLIT=30

    def __init__(self, input:TokenStream):
        super().__init__(input)
        self.checkVersion("4.5.1")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None



    class ProgramContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def data_decl_list(self):
            return self.getTypedRuleContext(TablaParser.Data_decl_listContext,0)


        def stat_list(self):
            return self.getTypedRuleContext(TablaParser.Stat_listContext,0)


        def EOF(self):
            return self.getToken(TablaParser.EOF, 0)

        def getRuleIndex(self):
            return TablaParser.RULE_program

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProgram" ):
                listener.enterProgram(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProgram" ):
                listener.exitProgram(self)




    def program(self):

        localctx = TablaParser.ProgramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_program)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 56
            self.data_decl_list()
            self.state = 57
            self.stat_list()
            self.state = 58
            self.match(TablaParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Data_decl_listContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def data_decl(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TablaParser.Data_declContext)
            else:
                return self.getTypedRuleContext(TablaParser.Data_declContext,i)


        def getRuleIndex(self):
            return TablaParser.RULE_data_decl_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterData_decl_list" ):
                listener.enterData_decl_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitData_decl_list" ):
                listener.exitData_decl_list(self)




    def data_decl_list(self):

        localctx = TablaParser.Data_decl_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_data_decl_list)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 63
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,0,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 60
                    self.data_decl() 
                self.state = 65
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,0,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Data_declContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def data_type(self):
            return self.getTypedRuleContext(TablaParser.Data_typeContext,0)


        def SEMI(self):
            return self.getToken(TablaParser.SEMI, 0)

        def getRuleIndex(self):
            return TablaParser.RULE_data_decl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterData_decl" ):
                listener.enterData_decl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitData_decl" ):
                listener.exitData_decl(self)




    def data_decl(self):

        localctx = TablaParser.Data_declContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_data_decl)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 66
            self.data_type()
            self.state = 67
            self.match(TablaParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Data_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def non_iterator(self):
            return self.getTypedRuleContext(TablaParser.Non_iteratorContext,0)


        def var_list(self):
            return self.getTypedRuleContext(TablaParser.Var_listContext,0)


        def GRADIENT(self):
            return self.getToken(TablaParser.GRADIENT, 0)

        def var_with_link_list(self):
            return self.getTypedRuleContext(TablaParser.Var_with_link_listContext,0)


        def iterator(self):
            return self.getTypedRuleContext(TablaParser.IteratorContext,0)


        def var_list_iterator(self):
            return self.getTypedRuleContext(TablaParser.Var_list_iteratorContext,0)


        def ID(self):
            return self.getToken(TablaParser.ID, 0)

        def ASSIGN(self):
            return self.getToken(TablaParser.ASSIGN, 0)

        def INTLIT(self):
            return self.getToken(TablaParser.INTLIT, 0)

        def getRuleIndex(self):
            return TablaParser.RULE_data_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterData_type" ):
                listener.enterData_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitData_type" ):
                listener.exitData_type(self)




    def data_type(self):

        localctx = TablaParser.Data_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_data_type)
        try:
            self.state = 80
            token = self._input.LA(1)
            if token in [TablaParser.MODEL_INPUT, TablaParser.MODEL_OUTPUT, TablaParser.MODEL]:
                self.enterOuterAlt(localctx, 1)
                self.state = 69
                self.non_iterator()
                self.state = 70
                self.var_list()

            elif token in [TablaParser.GRADIENT]:
                self.enterOuterAlt(localctx, 2)
                self.state = 72
                self.match(TablaParser.GRADIENT)
                self.state = 73
                self.var_with_link_list()

            elif token in [TablaParser.ITERATOR]:
                self.enterOuterAlt(localctx, 3)
                self.state = 74
                self.iterator()
                self.state = 75
                self.var_list_iterator()

            elif token in [TablaParser.ID]:
                self.enterOuterAlt(localctx, 4)
                self.state = 77
                self.match(TablaParser.ID)
                self.state = 78
                self.match(TablaParser.ASSIGN)
                self.state = 79
                self.match(TablaParser.INTLIT)

            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Non_iteratorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MODEL_INPUT(self):
            return self.getToken(TablaParser.MODEL_INPUT, 0)

        def MODEL_OUTPUT(self):
            return self.getToken(TablaParser.MODEL_OUTPUT, 0)

        def MODEL(self):
            return self.getToken(TablaParser.MODEL, 0)

        def getRuleIndex(self):
            return TablaParser.RULE_non_iterator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNon_iterator" ):
                listener.enterNon_iterator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNon_iterator" ):
                listener.exitNon_iterator(self)




    def non_iterator(self):

        localctx = TablaParser.Non_iteratorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_non_iterator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 82
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << TablaParser.MODEL_INPUT) | (1 << TablaParser.MODEL_OUTPUT) | (1 << TablaParser.MODEL))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class IteratorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ITERATOR(self):
            return self.getToken(TablaParser.ITERATOR, 0)

        def getRuleIndex(self):
            return TablaParser.RULE_iterator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIterator" ):
                listener.enterIterator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIterator" ):
                listener.exitIterator(self)




    def iterator(self):

        localctx = TablaParser.IteratorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_iterator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 84
            self.match(TablaParser.ITERATOR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Var_with_link_listContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def var(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TablaParser.VarContext)
            else:
                return self.getTypedRuleContext(TablaParser.VarContext,i)


        def var_with_link_list_tail(self):
            return self.getTypedRuleContext(TablaParser.Var_with_link_list_tailContext,0)


        def getRuleIndex(self):
            return TablaParser.RULE_var_with_link_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVar_with_link_list" ):
                listener.enterVar_with_link_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVar_with_link_list" ):
                listener.exitVar_with_link_list(self)




    def var_with_link_list(self):

        localctx = TablaParser.Var_with_link_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_var_with_link_list)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 86
            self.var()
            self.state = 87
            self.match(TablaParser.T__0)
            self.state = 88
            self.var()
            self.state = 89
            self.var_with_link_list_tail()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Var_with_link_list_tailContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def var_with_link_list(self):
            return self.getTypedRuleContext(TablaParser.Var_with_link_listContext,0)


        def var_with_link_list_tail(self):
            return self.getTypedRuleContext(TablaParser.Var_with_link_list_tailContext,0)


        def getRuleIndex(self):
            return TablaParser.RULE_var_with_link_list_tail

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVar_with_link_list_tail" ):
                listener.enterVar_with_link_list_tail(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVar_with_link_list_tail" ):
                listener.exitVar_with_link_list_tail(self)




    def var_with_link_list_tail(self):

        localctx = TablaParser.Var_with_link_list_tailContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_var_with_link_list_tail)
        try:
            self.state = 96
            la_ = self._interp.adaptivePredict(self._input,2,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 91
                self.match(TablaParser.COMMA)
                self.state = 92
                self.var_with_link_list()
                self.state = 93
                self.var_with_link_list_tail()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Var_listContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def var(self):
            return self.getTypedRuleContext(TablaParser.VarContext,0)


        def var_list_tail(self):
            return self.getTypedRuleContext(TablaParser.Var_list_tailContext,0)


        def getRuleIndex(self):
            return TablaParser.RULE_var_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVar_list" ):
                listener.enterVar_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVar_list" ):
                listener.exitVar_list(self)




    def var_list(self):

        localctx = TablaParser.Var_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_var_list)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 98
            self.var()
            self.state = 99
            self.var_list_tail()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class VarContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def var_id(self):
            return self.getTypedRuleContext(TablaParser.Var_idContext,0)


        def getRuleIndex(self):
            return TablaParser.RULE_var

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVar" ):
                listener.enterVar(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVar" ):
                listener.exitVar(self)




    def var(self):

        localctx = TablaParser.VarContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_var)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 101
            self.var_id()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Var_idContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(TablaParser.ID, 0)

        def id_tail(self):
            return self.getTypedRuleContext(TablaParser.Id_tailContext,0)


        def getRuleIndex(self):
            return TablaParser.RULE_var_id

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVar_id" ):
                listener.enterVar_id(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVar_id" ):
                listener.exitVar_id(self)




    def var_id(self):

        localctx = TablaParser.Var_idContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_var_id)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 103
            self.match(TablaParser.ID)
            self.state = 104
            self.id_tail()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Id_tailContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_BRACK(self):
            return self.getToken(TablaParser.LEFT_BRACK, 0)

        def RIGHT_BRACK(self):
            return self.getToken(TablaParser.RIGHT_BRACK, 0)

        def id_tail(self):
            return self.getTypedRuleContext(TablaParser.Id_tailContext,0)


        def ID(self):
            return self.getToken(TablaParser.ID, 0)

        def INTLIT(self):
            return self.getToken(TablaParser.INTLIT, 0)

        def getRuleIndex(self):
            return TablaParser.RULE_id_tail

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterId_tail" ):
                listener.enterId_tail(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitId_tail" ):
                listener.exitId_tail(self)




    def id_tail(self):

        localctx = TablaParser.Id_tailContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_id_tail)
        self._la = 0 # Token type
        try:
            self.state = 111
            token = self._input.LA(1)
            if token in [TablaParser.LEFT_BRACK]:
                self.enterOuterAlt(localctx, 1)
                self.state = 106
                self.match(TablaParser.LEFT_BRACK)
                self.state = 107
                _la = self._input.LA(1)
                if not(_la==TablaParser.ID or _la==TablaParser.INTLIT):
                    self._errHandler.recoverInline(self)
                else:
                    self.consume()
                self.state = 108
                self.match(TablaParser.RIGHT_BRACK)
                self.state = 109
                self.id_tail()

            elif token in [TablaParser.T__0, TablaParser.ADD, TablaParser.SUB, TablaParser.LT, TablaParser.GT, TablaParser.MUL, TablaParser.SEMI, TablaParser.RIGHT_PAREN, TablaParser.COMMA, TablaParser.ASSIGN]:
                self.enterOuterAlt(localctx, 2)


            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Var_list_tailContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COMMA(self):
            return self.getToken(TablaParser.COMMA, 0)

        def var_list(self):
            return self.getTypedRuleContext(TablaParser.Var_listContext,0)


        def getRuleIndex(self):
            return TablaParser.RULE_var_list_tail

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVar_list_tail" ):
                listener.enterVar_list_tail(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVar_list_tail" ):
                listener.exitVar_list_tail(self)




    def var_list_tail(self):

        localctx = TablaParser.Var_list_tailContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_var_list_tail)
        try:
            self.state = 116
            token = self._input.LA(1)
            if token in [TablaParser.COMMA]:
                self.enterOuterAlt(localctx, 1)
                self.state = 113
                self.match(TablaParser.COMMA)
                self.state = 114
                self.var_list()

            elif token in [TablaParser.SEMI]:
                self.enterOuterAlt(localctx, 2)


            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Var_list_iteratorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(TablaParser.ID)
            else:
                return self.getToken(TablaParser.ID, i)

        def LEFT_BRACK(self):
            return self.getToken(TablaParser.LEFT_BRACK, 0)

        def COLON(self):
            return self.getToken(TablaParser.COLON, 0)

        def RIGHT_BRACK(self):
            return self.getToken(TablaParser.RIGHT_BRACK, 0)

        def INTLIT(self, i:int=None):
            if i is None:
                return self.getTokens(TablaParser.INTLIT)
            else:
                return self.getToken(TablaParser.INTLIT, i)

        def getRuleIndex(self):
            return TablaParser.RULE_var_list_iterator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVar_list_iterator" ):
                listener.enterVar_list_iterator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVar_list_iterator" ):
                listener.exitVar_list_iterator(self)




    def var_list_iterator(self):

        localctx = TablaParser.Var_list_iteratorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_var_list_iterator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 118
            self.match(TablaParser.ID)
            self.state = 119
            self.match(TablaParser.LEFT_BRACK)
            self.state = 120
            _la = self._input.LA(1)
            if not(_la==TablaParser.ID or _la==TablaParser.INTLIT):
                self._errHandler.recoverInline(self)
            else:
                self.consume()
            self.state = 121
            self.match(TablaParser.COLON)
            self.state = 122
            _la = self._input.LA(1)
            if not(_la==TablaParser.ID or _la==TablaParser.INTLIT):
                self._errHandler.recoverInline(self)
            else:
                self.consume()
            self.state = 123
            self.match(TablaParser.RIGHT_BRACK)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Stat_listContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def stat(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TablaParser.StatContext)
            else:
                return self.getTypedRuleContext(TablaParser.StatContext,i)


        def getRuleIndex(self):
            return TablaParser.RULE_stat_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStat_list" ):
                listener.enterStat_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStat_list" ):
                listener.exitStat_list(self)




    def stat_list(self):

        localctx = TablaParser.Stat_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_stat_list)
        self._la = 0 # Token type
        try:
            self.state = 132
            la_ = self._interp.adaptivePredict(self._input,6,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 128
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==TablaParser.ID:
                    self.state = 125
                    self.stat()
                    self.state = 130
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class StatContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def var(self):
            return self.getTypedRuleContext(TablaParser.VarContext,0)


        def ASSIGN(self):
            return self.getToken(TablaParser.ASSIGN, 0)

        def expr(self):
            return self.getTypedRuleContext(TablaParser.ExprContext,0)


        def SEMI(self):
            return self.getToken(TablaParser.SEMI, 0)

        def getRuleIndex(self):
            return TablaParser.RULE_stat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStat" ):
                listener.enterStat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStat" ):
                listener.exitStat(self)




    def stat(self):

        localctx = TablaParser.StatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_stat)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 134
            self.var()
            self.state = 135
            self.match(TablaParser.ASSIGN)
            self.state = 136
            self.expr()
            self.state = 137
            self.match(TablaParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ExprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def term2(self):
            return self.getTypedRuleContext(TablaParser.Term2Context,0)


        def term2_tail(self):
            return self.getTypedRuleContext(TablaParser.Term2_tailContext,0)


        def getRuleIndex(self):
            return TablaParser.RULE_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpr" ):
                listener.enterExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpr" ):
                listener.exitExpr(self)




    def expr(self):

        localctx = TablaParser.ExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_expr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 139
            self.term2()
            self.state = 140
            self.term2_tail()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FunctionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PI(self):
            return self.getToken(TablaParser.PI, 0)

        def SUM(self):
            return self.getToken(TablaParser.SUM, 0)

        def NORM(self):
            return self.getToken(TablaParser.NORM, 0)

        def GAUSSIAN(self):
            return self.getToken(TablaParser.GAUSSIAN, 0)

        def SIGMOID(self):
            return self.getToken(TablaParser.SIGMOID, 0)

        def SIG_SYM(self):
            return self.getToken(TablaParser.SIG_SYM, 0)

        def LOG(self):
            return self.getToken(TablaParser.LOG, 0)

        def getRuleIndex(self):
            return TablaParser.RULE_function

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunction" ):
                listener.enterFunction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunction" ):
                listener.exitFunction(self)




    def function(self):

        localctx = TablaParser.FunctionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_function)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 142
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << TablaParser.PI) | (1 << TablaParser.SUM) | (1 << TablaParser.NORM) | (1 << TablaParser.GAUSSIAN) | (1 << TablaParser.SIGMOID) | (1 << TablaParser.SIG_SYM) | (1 << TablaParser.LOG))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Function_argsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_BRACK(self):
            return self.getToken(TablaParser.LEFT_BRACK, 0)

        def ID(self):
            return self.getToken(TablaParser.ID, 0)

        def RIGHT_BRACK(self):
            return self.getToken(TablaParser.RIGHT_BRACK, 0)

        def LEFT_PAREN(self):
            return self.getToken(TablaParser.LEFT_PAREN, 0)

        def expr(self):
            return self.getTypedRuleContext(TablaParser.ExprContext,0)


        def RIGHT_PAREN(self):
            return self.getToken(TablaParser.RIGHT_PAREN, 0)

        def getRuleIndex(self):
            return TablaParser.RULE_function_args

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunction_args" ):
                listener.enterFunction_args(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunction_args" ):
                listener.exitFunction_args(self)




    def function_args(self):

        localctx = TablaParser.Function_argsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_function_args)
        try:
            self.state = 155
            token = self._input.LA(1)
            if token in [TablaParser.LEFT_BRACK]:
                self.enterOuterAlt(localctx, 1)
                self.state = 144
                self.match(TablaParser.LEFT_BRACK)
                self.state = 145
                self.match(TablaParser.ID)
                self.state = 146
                self.match(TablaParser.RIGHT_BRACK)
                self.state = 147
                self.match(TablaParser.LEFT_PAREN)
                self.state = 148
                self.expr()
                self.state = 149
                self.match(TablaParser.RIGHT_PAREN)

            elif token in [TablaParser.LEFT_PAREN]:
                self.enterOuterAlt(localctx, 2)
                self.state = 151
                self.match(TablaParser.LEFT_PAREN)
                self.state = 152
                self.expr()
                self.state = 153
                self.match(TablaParser.RIGHT_PAREN)

            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Term2_tailContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def compare_op(self):
            return self.getTypedRuleContext(TablaParser.Compare_opContext,0)


        def term2(self):
            return self.getTypedRuleContext(TablaParser.Term2Context,0)


        def term2_tail(self):
            return self.getTypedRuleContext(TablaParser.Term2_tailContext,0)


        def getRuleIndex(self):
            return TablaParser.RULE_term2_tail

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTerm2_tail" ):
                listener.enterTerm2_tail(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTerm2_tail" ):
                listener.exitTerm2_tail(self)




    def term2_tail(self):

        localctx = TablaParser.Term2_tailContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_term2_tail)
        try:
            self.state = 162
            token = self._input.LA(1)
            if token in [TablaParser.LT, TablaParser.GT]:
                self.enterOuterAlt(localctx, 1)
                self.state = 157
                self.compare_op()
                self.state = 158
                self.term2()
                self.state = 159
                self.term2_tail()

            elif token in [TablaParser.SEMI, TablaParser.RIGHT_PAREN]:
                self.enterOuterAlt(localctx, 2)


            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Term2Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def term1(self):
            return self.getTypedRuleContext(TablaParser.Term1Context,0)


        def term1_tail(self):
            return self.getTypedRuleContext(TablaParser.Term1_tailContext,0)


        def getRuleIndex(self):
            return TablaParser.RULE_term2

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTerm2" ):
                listener.enterTerm2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTerm2" ):
                listener.exitTerm2(self)




    def term2(self):

        localctx = TablaParser.Term2Context(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_term2)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 164
            self.term1()
            self.state = 165
            self.term1_tail()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Term1_tailContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def add_op(self):
            return self.getTypedRuleContext(TablaParser.Add_opContext,0)


        def term1(self):
            return self.getTypedRuleContext(TablaParser.Term1Context,0)


        def term1_tail(self):
            return self.getTypedRuleContext(TablaParser.Term1_tailContext,0)


        def getRuleIndex(self):
            return TablaParser.RULE_term1_tail

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTerm1_tail" ):
                listener.enterTerm1_tail(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTerm1_tail" ):
                listener.exitTerm1_tail(self)




    def term1_tail(self):

        localctx = TablaParser.Term1_tailContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_term1_tail)
        try:
            self.state = 172
            token = self._input.LA(1)
            if token in [TablaParser.ADD, TablaParser.SUB]:
                self.enterOuterAlt(localctx, 1)
                self.state = 167
                self.add_op()
                self.state = 168
                self.term1()
                self.state = 169
                self.term1_tail()

            elif token in [TablaParser.LT, TablaParser.GT, TablaParser.SEMI, TablaParser.RIGHT_PAREN]:
                self.enterOuterAlt(localctx, 2)


            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Term1Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def term0(self):
            return self.getTypedRuleContext(TablaParser.Term0Context,0)


        def term0_tail(self):
            return self.getTypedRuleContext(TablaParser.Term0_tailContext,0)


        def getRuleIndex(self):
            return TablaParser.RULE_term1

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTerm1" ):
                listener.enterTerm1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTerm1" ):
                listener.exitTerm1(self)




    def term1(self):

        localctx = TablaParser.Term1Context(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_term1)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 174
            self.term0()
            self.state = 175
            self.term0_tail()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Term0_tailContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def mul_op(self):
            return self.getTypedRuleContext(TablaParser.Mul_opContext,0)


        def term0(self):
            return self.getTypedRuleContext(TablaParser.Term0Context,0)


        def term0_tail(self):
            return self.getTypedRuleContext(TablaParser.Term0_tailContext,0)


        def getRuleIndex(self):
            return TablaParser.RULE_term0_tail

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTerm0_tail" ):
                listener.enterTerm0_tail(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTerm0_tail" ):
                listener.exitTerm0_tail(self)




    def term0_tail(self):

        localctx = TablaParser.Term0_tailContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_term0_tail)
        try:
            self.state = 182
            token = self._input.LA(1)
            if token in [TablaParser.MUL]:
                self.enterOuterAlt(localctx, 1)
                self.state = 177
                self.mul_op()
                self.state = 178
                self.term0()
                self.state = 179
                self.term0_tail()

            elif token in [TablaParser.ADD, TablaParser.SUB, TablaParser.LT, TablaParser.GT, TablaParser.SEMI, TablaParser.RIGHT_PAREN]:
                self.enterOuterAlt(localctx, 2)


            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Term0Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def var(self):
            return self.getTypedRuleContext(TablaParser.VarContext,0)


        def LEFT_PAREN(self):
            return self.getToken(TablaParser.LEFT_PAREN, 0)

        def expr(self):
            return self.getTypedRuleContext(TablaParser.ExprContext,0)


        def RIGHT_PAREN(self):
            return self.getToken(TablaParser.RIGHT_PAREN, 0)

        def INTLIT(self):
            return self.getToken(TablaParser.INTLIT, 0)

        def function(self):
            return self.getTypedRuleContext(TablaParser.FunctionContext,0)


        def function_args(self):
            return self.getTypedRuleContext(TablaParser.Function_argsContext,0)


        def getRuleIndex(self):
            return TablaParser.RULE_term0

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTerm0" ):
                listener.enterTerm0(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTerm0" ):
                listener.exitTerm0(self)




    def term0(self):

        localctx = TablaParser.Term0Context(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_term0)
        try:
            self.state = 193
            token = self._input.LA(1)
            if token in [TablaParser.ID]:
                self.enterOuterAlt(localctx, 1)
                self.state = 184
                self.var()

            elif token in [TablaParser.LEFT_PAREN]:
                self.enterOuterAlt(localctx, 2)
                self.state = 185
                self.match(TablaParser.LEFT_PAREN)
                self.state = 186
                self.expr()
                self.state = 187
                self.match(TablaParser.RIGHT_PAREN)

            elif token in [TablaParser.INTLIT]:
                self.enterOuterAlt(localctx, 3)
                self.state = 189
                self.match(TablaParser.INTLIT)

            elif token in [TablaParser.PI, TablaParser.SUM, TablaParser.NORM, TablaParser.GAUSSIAN, TablaParser.SIGMOID, TablaParser.SIG_SYM, TablaParser.LOG]:
                self.enterOuterAlt(localctx, 4)
                self.state = 190
                self.function()
                self.state = 191
                self.function_args()

            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Mul_opContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MUL(self):
            return self.getToken(TablaParser.MUL, 0)

        def getRuleIndex(self):
            return TablaParser.RULE_mul_op

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMul_op" ):
                listener.enterMul_op(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMul_op" ):
                listener.exitMul_op(self)




    def mul_op(self):

        localctx = TablaParser.Mul_opContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_mul_op)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 195
            self.match(TablaParser.MUL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Add_opContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ADD(self):
            return self.getToken(TablaParser.ADD, 0)

        def SUB(self):
            return self.getToken(TablaParser.SUB, 0)

        def getRuleIndex(self):
            return TablaParser.RULE_add_op

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAdd_op" ):
                listener.enterAdd_op(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAdd_op" ):
                listener.exitAdd_op(self)




    def add_op(self):

        localctx = TablaParser.Add_opContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_add_op)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 197
            _la = self._input.LA(1)
            if not(_la==TablaParser.ADD or _la==TablaParser.SUB):
                self._errHandler.recoverInline(self)
            else:
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Compare_opContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LT(self):
            return self.getToken(TablaParser.LT, 0)

        def GT(self):
            return self.getToken(TablaParser.GT, 0)

        def getRuleIndex(self):
            return TablaParser.RULE_compare_op

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCompare_op" ):
                listener.enterCompare_op(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCompare_op" ):
                listener.exitCompare_op(self)




    def compare_op(self):

        localctx = TablaParser.Compare_opContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_compare_op)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 199
            _la = self._input.LA(1)
            if not(_la==TablaParser.LT or _la==TablaParser.GT):
                self._errHandler.recoverInline(self)
            else:
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





